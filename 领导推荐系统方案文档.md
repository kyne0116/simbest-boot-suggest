# 领导推荐系统方案文档

## 目录

1. [项目概述](#1-项目概述)
2. [系统设计](#2-系统设计)
   - [2.1 设计目标](#21-设计目标)
   - [2.2 系统架构](#22-系统架构)
   - [2.3 数据模型](#23-数据模型)
   - [2.4 推荐算法](#24-推荐算法)
3. [关键技术](#3-关键技术)
   - [3.1 文本相似度算法](#31-文本相似度算法)
   - [3.2 多级匹配策略](#32-多级匹配策略)
   - [3.3 静态数据映射](#33-静态数据映射)
4. [代码实现](#4-代码实现)
   - [4.1 数据模型类](#41-数据模型类)
   - [4.2 服务类](#42-服务类)
   - [4.3 演示程序](#43-演示程序)
5. [数据初始化](#5-数据初始化)
   - [5.1 组织数据](#51-组织数据)
   - [5.2 领导数据](#52-领导数据)
   - [5.3 职责领域数据](#53-职责领域数据)
6. [使用方式](#6-使用方式)
   - [6.1 API 接口](#61-api接口)
   - [6.2 演示程序](#62-演示程序)
   - [6.3 使用示例](#63-使用示例)
7. [测试结果](#7-测试结果)
8. [后续改进方向](#8-后续改进方向)

## 1. 项目概述

领导推荐系统是一个基于 Java 开发的智能推荐系统，旨在根据当前办理人账号、组织和任务标题，推荐最合适的领导账号。系统通过建立候选领导与分管组织、职责领域的静态映射关系，结合文本相似度算法，实现了智能化的领导推荐功能。

系统按照以下优先级进行推荐：

1. 基于组织关系的匹配：如果当前办理人所在组织有对应的分管领导，直接推荐该领导
2. 基于职责领域的匹配：如果任务标题与某个职责领域匹配度较高，推荐该领域的负责领导
3. 基于文本相似度的匹配：如果前两种方法都没有找到匹配的领导，使用文本相似度算法推荐最匹配的领导

## 2. 系统设计

### 2.1 设计目标

- 建立候选领导与分管组织的静态映射关系
- 建立候选领导与职责领域的静态映射关系
- 提供 API 接口，根据当前办理人账号、组织和任务标题，推荐最合适的领导账号
- 按照优先级进行推荐：组织关系匹配 > 职责领域匹配 > 文本相似度匹配
- 提供详细的推荐理由和匹配度评分

### 2.2 系统架构

系统采用分层架构设计，主要包括以下几个部分：

1. **数据模型层**：定义系统中的核心数据模型，包括组织、领导、职责领域和推荐结果等
2. **服务层**：提供核心业务逻辑，包括组织管理、领导管理、职责领域管理和推荐服务等
3. **接口层**：提供 API 接口，供外部系统调用
4. **演示层**：提供演示程序，用于测试和展示系统功能

系统架构图：

```
+------------------+
|    演示程序       |
+------------------+
         |
         v
+------------------+
|    推荐服务       |
+------------------+
         |
         v
+----------------------------------+
|                                  |
|  组织服务    领导服务    职责领域服务  |
|                                  |
+----------------------------------+
         |
         v
+----------------------------------+
|                                  |
|  组织模型    领导模型    职责领域模型  |
|                                  |
+----------------------------------+
```

### 2.3 数据模型

系统定义了以下核心数据模型：

1. **Organization（组织）**：表示一个组织及其分管领导

   - orgId：组织 ID
   - orgName：组织名称
   - parentOrgId：父组织 ID
   - leaderAccount：分管领导账号

2. **Leader（领导）**：表示一个领导及其分管组织和职责领域

   - account：领导账号
   - name：领导姓名
   - orgIds：分管组织 ID 列表
   - domainIds：负责的职责领域 ID 列表

3. **ResponsibilityDomain（职责领域）**：表示一个特定的业务领域及其关键词和负责人

   - domainId：领域 ID
   - domainName：领域名称
   - responsiblePerson：负责人
   - keywords：关键词列表
   - description：领域描述

4. **RecommendationResult（推荐结果）**：表示一个推荐结果，包含推荐的领导账号、推荐理由和匹配分数
   - leaderAccount：推荐的领导账号
   - leaderName：推荐的领导姓名
   - reason：推荐理由
   - score：匹配分数

### 2.4 推荐算法

系统采用多级匹配策略进行推荐，按照以下优先级：

1. **基于组织关系的匹配**：

   - 根据当前办理人组织 ID，查找对应的分管领导
   - 如果找到分管领导，直接推荐该领导，匹配度为 100%

2. **基于职责领域的匹配**：

   - 计算任务标题与各个职责领域的匹配度
   - 如果最高匹配度超过阈值（30%），推荐该职责领域的负责领导

3. **基于文本相似度的匹配**：
   - 计算任务标题与各个职责领域关键词的文本相似度
   - 推荐文本相似度最高的职责领域的负责领导

## 3. 关键技术

### 3.1 文本相似度算法

系统实现了多种文本相似度算法，用于计算任务标题与职责领域关键词的相似度：

1. **字符级相似度算法**：

   - **Jaccard 相似度**：计算两个集合的交集大小除以并集大小
   - **余弦相似度**：计算两个向量的点积除以向量模的乘积
   - **Levenshtein 距离**：计算将一个字符串转换为另一个字符串所需的最少编辑操作数

2. **词语级相似度算法**：

   - **基于分词的 Jaccard 相似度**：在词语级别计算 Jaccard 相似度
   - **基于分词的余弦相似度**：在词语级别计算余弦相似度

3. **综合相似度算法**：
   - **字符级综合相似度**：结合字符级的多种算法，取加权平均值
   - **词语级综合相似度**：结合词语级的多种算法，取加权平均值
   - **最终综合相似度**：结合字符级和词语级的综合相似度，提供更全面的相似度评估

这种多层次的相似度计算方法能够更全面地捕捉文本之间的语义相似性，提高匹配的准确性。

### 3.2 多级匹配策略

系统采用多级匹配策略，按照优先级依次尝试不同的匹配方法：

1. **组织关系匹配**：直接根据组织 ID 查找分管领导，最简单但最准确
2. **职责领域匹配**：根据任务标题中的关键词匹配职责领域，适用于任务标题明确包含关键词的情况
3. **文本相似度匹配**：使用文本相似度算法进行匹配，适用于任务标题与关键词不完全匹配的情况

这种多级匹配策略既保证了匹配的准确性，又提供了足够的灵活性。

### 3.3 中文分词和同义词匹配

为了提高匹配的准确性，系统实现了中文分词和同义词匹配功能：

1. **中文分词**：

   - 使用最大正向匹配算法进行中文分词
   - 基于预定义的词典进行分词，词典包含系统中的所有关键词和常用词
   - 分词结果用于词语级相似度计算和关键词匹配

2. **同义词匹配**：
   - 建立同义词表，存储常用同义词组
   - 在关键词匹配时，考虑同义词的匹配
   - 同义词匹配给予较低的权重，但能显著提高匹配的灵活性

这些功能的实现显著提高了系统对中文文本的处理能力，使得匹配结果更加准确和全面。

### 3.4 动态阈值调整

系统实现了动态阈值调整机制，根据任务标题的特征动态调整匹配阈值：

1. **基于标题长度的调整**：

   - 标题越长，阈值适当降低，提高匹配成功率
   - 标题越短，阈值保持较高，确保匹配准确性

2. **基于标题内容的调整**：
   - 当标题包含特定关键词（如“紧急”、“重要”）时，适当降低阈值
   - 根据不同类型的任务标题调整阈值策略

动态阈值调整机制使系统能够更灵活地应对不同类型的任务标题，提高了推荐的适应性。

### 3.5 静态数据映射

系统使用静态数据建立了候选领导与分管组织、职责领域的映射关系：

1. **领导-组织映射**：每个领导负责一个或多个组织
2. **领导-职责领域映射**：每个领导负责一个或多个职责领域
3. **职责领域-关键词映射**：每个职责领域包含多个关键词

这些静态映射关系在系统初始化时加载，可以根据实际需求进行调整。

## 4. 代码实现

### 4.1 数据模型类

#### 4.1.1 Organization.java

```java
public class Organization {
    private String orgId;          // 组织ID
    private String orgName;        // 组织名称
    private String parentOrgId;    // 父组织ID
    private String leaderAccount;  // 分管领导账号

    // 构造函数、getter和setter方法
}
```

#### 4.1.2 Leader.java

```java
public class Leader {
    private String account;        // 领导账号
    private String name;           // 领导姓名
    private List<String> orgIds;   // 分管组织ID列表
    private List<String> domainIds; // 负责的职责领域ID列表

    // 构造函数、getter和setter方法
}
```

#### 4.1.3 ResponsibilityDomain.java

```java
public class ResponsibilityDomain {
    private String domainId;       // 领域ID
    private String domainName;     // 领域名称
    private String responsiblePerson; // 负责人
    private List<String> keywords; // 关键词列表
    private String description;    // 领域描述

    // 构造函数、getter和setter方法

    // 计算文本与该领域的匹配度
    public double calculateMatchScore(String text) {
        // 分词处理输入文本
        List<String> textTokens = ChineseTokenizer.tokenize(text);

        // 初始化关键词权重
        Map<String, Double> keywordWeights = new HashMap<>();
        for (String keyword : keywords) {
            // 关键词长度越长，权重越高
            double weight = 1.0 + (0.1 * Math.min(keyword.length(), 10));
            keywordWeights.put(keyword, weight);
        }

        // 计算匹配的关键词，考虑直接匹配、分词匹配和同义词匹配
        // ...

        // 综合评分：60%基于匹配关键词数量，40%基于加权分数
        return 0.6 * keywordCountRatio + 0.4 * weightedRatio;
    }

    // 获取匹配的关键词列表
    public List<String> getMatchedKeywords(String text) {
        // 分词处理输入文本
        List<String> textTokens = ChineseTokenizer.tokenize(text);

        // 计算匹配的关键词，考虑直接匹配、分词匹配和同义词匹配
        // 如果是同义词匹配，返回匹配的同义词信息
        // ...

        return matchedKeywords;
    }
}
```

#### 4.1.4 RecommendationResult.java

```java
public class RecommendationResult {
    private String leaderAccount;  // 推荐的领导账号
    private String leaderName;     // 推荐的领导姓名
    private String reason;         // 推荐理由
    private double score;          // 匹配分数

    // 构造函数、getter和setter方法
}
```

### 4.2 服务类

#### 4.2.1 OrganizationService.java

```java
public class OrganizationService {
    private Map<String, Organization> organizations; // 组织ID到组织的映射
    private Map<String, List<String>> leaderOrgMap;  // 领导账号到分管组织ID的映射

    // 初始化组织数据
    public void initOrganizations() {
        // 初始化组织数据
    }

    // 根据组织ID获取分管领导账号
    public String getLeaderAccountByOrgId(String orgId) {
        // 获取分管领导账号的逻辑
    }

    // 其他方法
}
```

#### 4.2.2 LeaderService.java

```java
public class LeaderService {
    private Map<String, Leader> leaders; // 领导账号到领导的映射

    // 初始化领导数据
    public void initLeaders() {
        // 初始化领导数据
    }

    // 根据账号获取领导
    public Leader getLeaderByAccount(String account) {
        // 获取领导的逻辑
    }

    // 其他方法
}
```

#### 4.2.3 DomainService.java

```java
public class DomainService {
    private Map<String, ResponsibilityDomain> domains; // 领域ID到领域的映射
    private Map<String, List<String>> leaderDomainMap; // 领导账号到负责领域ID的映射

    // 初始化职责领域数据
    public void initDomains() {
        // 初始化职责领域数据
    }

    // 计算任务标题与职责领域的匹配度
    public double calculateMatchScore(String taskTitle, ResponsibilityDomain domain) {
        // 计算匹配度的逻辑
    }

    // 其他方法
}
```

#### 4.2.4 RecommendationService.java

```java
public class RecommendationService {
    private OrganizationService organizationService;
    private LeaderService leaderService;
    private DomainService domainService;

    // 推荐领导账号
    public RecommendationResult recommendLeader(String currentUserAccount,
                                              String currentUserOrgId,
                                              String taskTitle) {
        // 推荐领导的逻辑
    }

    // 基于组织关系推荐领导
    public RecommendationResult recommendLeaderByOrganization(String orgId) {
        // 基于组织关系推荐的逻辑
    }

    // 基于职责领域推荐领导
    public RecommendationResult recommendLeaderByDomain(String taskTitle) {
        // 基于职责领域推荐的逻辑
    }

    // 基于文本相似度推荐领导
    public RecommendationResult recommendLeaderBySimilarity(String taskTitle) {
        // 基于文本相似度推荐的逻辑
    }
}
```

### 4.3 演示程序

#### 4.3.1 LeaderRecommendationDemo.java

```java
public class LeaderRecommendationDemo {
    public static void main(String[] args) {
        // 创建服务
        OrganizationService organizationService = new OrganizationService();
        LeaderService leaderService = new LeaderService();
        DomainService domainService = new DomainService();
        RecommendationService recommendationService = new RecommendationService(
                organizationService, leaderService, domainService);

        // 演示程序逻辑
    }
}
```

## 5. 数据初始化

系统使用静态数据初始化组织、领导和职责领域的信息。在实际应用中，这些数据可以从数据库或配置文件中加载。

### 5.1 组织数据

系统初始化了以下组织数据：

| 组织 ID | 组织名称   | 父组织 ID | 分管领导账号 |
| ------- | ---------- | --------- | ------------ |
| org001  | 信息安全部 | org000    | xuhyun       |
| org002  | 计费账务部 | org000    | zhangyk      |
| org003  | 系统管理部 | org000    | zhaobin      |
| org004  | 数据治理部 | org000    | zhaobin      |
| org005  | 网络安全部 | org001    | xuhyun       |
| org006  | 信息安全室 | org001    | xuhyun       |
| org007  | 计费系统部 | org002    | zhangyk      |
| org008  | 账务结算部 | org002    | zhangyk      |
| org009  | 短信营销部 | org002    | zhangyk      |
| org010  | 系统建设部 | org003    | zhaobin      |
| org011  | 系统运维部 | org003    | zhaobin      |
| org012  | 数据分析部 | org004    | zhaobin      |
| org013  | AI 研发部  | org004    | zhaobin      |

### 5.2 领导数据

系统初始化了以下领导数据：

| 领导账号 | 领导姓名 | 分管组织 ID                                    | 负责的职责领域 ID    |
| -------- | -------- | ---------------------------------------------- | -------------------- |
| xuhyun   | 许慧云   | org001, org005, org006                         | domain001            |
| zhangyk  | 张耀华   | org002, org007, org008, org009                 | domain002            |
| zhaobin  | 赵斌     | org003, org004, org010, org011, org012, org013 | domain003, domain004 |

### 5.3 职责领域数据

系统初始化了以下职责领域数据：

| 领域 ID   | 领域名称 | 负责人 | 关键词                                                                                                                                                                                                                       |
| --------- | -------- | ------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| domain001 | 网络安全 | 许慧云 | 安全, 网络安全, 信息安全, 网信安全, 互联网信安, 安全评估, 安全监督, 安全检查, 网络安全专项行动, 春耕, 两会, 网信, 漏洞, 风险, 监督, 检查, 评估, 保密                                                                         |
| domain002 | 计费账务 | 张耀华 | 计费, 账务, 结算, 短信, 营销, 在线营销, 短信平台, 端口, 扩展号码, 10086, 账单, 计费系统, 账务系统, 账务调整, 计费账务, 软件维护, 平台维护, 系统维护, 中台, 规划, 网间结算, 省内结算                                          |
| domain003 | 系统管理 | 赵斌   | 运营管理, 管理信息系统, 政企业务, 支撑, 系统建设, 支撑需求, 业务支撑, 政企, 管理系统, 信息系统, 系统管理, 运营, 建设, 管理协调, 生产经营, 精益管理, 协作配合, 管理工作, 反馈, 协调, 管理, 协作, 配合, 工作, 台账, 管控, 事项 |
| domain004 | 数据治理 | 赵斌   | 数据治理, 智能体, 智算资源, 数智化, 自主可控, AI, 人工智能, 灵犀, 数据, 治理, 统计局, 研发, 科研档案, 年报, 统计, 研发项目, 佐证材料                                                                                         |

## 6. 使用方式

### 6.1 API 接口

系统提供了以下 API 接口：

```java
/**
 * 推荐领导账号
 * @param currentUserAccount 当前办理人账号
 * @param currentUserOrgId 当前办理人组织ID
 * @param taskTitle 任务标题
 * @return 推荐结果
 */
public RecommendationResult recommendLeader(String currentUserAccount,
                                          String currentUserOrgId,
                                          String taskTitle);

/**
 * 获取所有可能的推荐结果
 * @param currentUserAccount 当前办理人账号
 * @param currentUserOrgId 当前办理人组织ID
 * @param taskTitle 任务标题
 * @return 所有可能的推荐结果列表
 */
public List<RecommendationResult> getAllPossibleRecommendations(String currentUserAccount,
                                                              String currentUserOrgId,
                                                              String taskTitle);
```

### 6.2 演示程序

系统提供了一个演示程序 `LeaderRecommendationDemo`，用于测试和展示系统功能。演示程序的使用步骤如下：

1. 编译代码：

   ```
   javac -encoding UTF-8 -d target/classes src/main/java/org/nccpn/personnel/model/*.java src/main/java/org/nccpn/personnel/service/*.java src/main/java/org/nccpn/personnel/demo/*.java
   ```

2. 运行演示程序：

   ```
   java -cp target/classes org.nccpn.personnel.demo.LeaderRecommendationDemo
   ```

3. 按照提示输入当前办理人账号、组织 ID 和任务标题，查看推荐结果。

### 6.3 使用示例

以下是几个使用示例：

#### 示例 1：基于组织关系的匹配

- 当前办理人账号：user001
- 当前办理人组织 ID：org001（信息安全部）
- 任务标题：关于做好全国"两会"网信安全保障工作通知

推荐结果：

```
推荐结果：许慧云(xuhyun)，理由：组织关系匹配：信息安全部，匹配度：100.00%
```

所有可能的推荐结果：

```
1. 推荐结果：许慧云(xuhyun)，理由：组织关系匹配：信息安全部，匹配度：100.00%
2. 推荐结果：许慧云(xuhyun)，理由：职责领域匹配：网络安全，匹配关键词：安全、网信安全、两会、网信，匹配度：30.56%
3. 推荐结果：许慧云(xuhyun)，理由：文本相似度匹配：网络安全，最匹配关键词：网信安全，匹配度：33.08%
```

#### 示例 2：基于职责领域的匹配

- 当前办理人账号：user003
- 当前办理人组织 ID：org999（不存在的组织）
- 任务标题：关于数据治理和 AI 智能体建设项目的协作配合

推荐结果：

```
推荐结果：赵斌(zhaobin)，理由：职责领域匹配：数据治理，匹配关键词：数据治理、智能体、AI、数据、治理，匹配度：39.16%
```

所有可能的推荐结果：

```
1. 推荐结果：赵斌(zhaobin)，理由：职责领域匹配：数据治理，匹配关键词：数据治理、智能体、AI、数据、治理，匹配度：39.16%
2. 推荐结果：赵斌(zhaobin)，理由：文本相似度匹配：系统管理，最匹配关键词：协作配合，匹配度：28.89%
```

#### 示例 3：基于文本相似度的匹配

- 当前办理人账号：user003
- 当前办理人组织 ID：org999（不存在的组织）
- 任务标题：关于短信扩展号码申请的请示

推荐结果：

```
推荐结果：张耀华(zhangyk)，理由：文本相似度匹配：计费账务，最匹配关键词：扩展号码，匹配度：39.89%
```

所有可能的推荐结果：

```
1. 推荐结果：张耀华(zhangyk)，理由：文本相似度匹配：计费账务，最匹配关键词：扩展号码，匹配度：39.89%
```

## 7. 测试结果

系统测试结果表明，推荐系统能够正确地按照优先级进行推荐，并提供详细的推荐理由和匹配度。测试覆盖了以下场景：

1. **组织关系匹配**：当当前办理人所在组织有对应的分管领导时，系统能够正确推荐该领导。
2. **职责领域匹配**：当任务标题与某个职责领域匹配度较高时，系统能够正确推荐该领域的负责领导。
3. **文本相似度匹配**：当前两种方法都没有找到匹配的领导时，系统能够使用文本相似度算法推荐最匹配的领导。

测试结果显示，系统在各种场景下都能提供合理的推荐结果，并给出详细的推荐理由和匹配度评分。

### 4.1.5 TextSimilarityUtil.java

```java
public class TextSimilarityUtil {
    // 字符级相似度算法
    public static double calculateJaccardSimilarity(String text1, String text2) {
        // 计算Jaccard相似度
    }

    public static double calculateCosineSimilarity(String text1, String text2) {
        // 计算余弦相似度
    }

    public static double calculateLevenshteinSimilarity(String text1, String text2) {
        // 计算Levenshtein相似度
    }

    // 词语级相似度算法
    public static double calculateTokenJaccardSimilarity(String text1, String text2) {
        // 计算基于分词的Jaccard相似度
    }

    public static double calculateTokenCosineSimilarity(String text1, String text2) {
        // 计算基于分词的余弦相似度
    }

    // 综合相似度算法
    public static double calculateOverallSimilarity(String text1, String text2) {
        // 计算字符级综合相似度
    }

    public static double calculateTokenOverallSimilarity(String text1, String text2) {
        // 计算词语级综合相似度
    }

    public static double calculateFinalSimilarity(String text1, String text2) {
        // 计算最终综合相似度，结合字符级和词语级相似度
    }
}
```

### 4.1.6 ChineseTokenizer.java

```java
public class ChineseTokenizer {
    private static final Set<String> dictionary = new HashSet<>();

    // 初始化词典
    public static synchronized void initialize() {
        // 从资源文件加载词典
        // 添加一些常用词
    }

    // 分词
    public static List<String> tokenize(String text) {
        // 使用最大正向匹配算法进行分词
    }

    // 判断文本是否包含指定词语（精确匹配）
    public static boolean containsWord(String text, String word) {
        // 判断文本是否包含指定词语
    }
}
```

### 4.1.7 SynonymManager.java

```java
public class SynonymManager {
    private static final Map<String, Set<String>> synonyms = new HashMap<>();

    // 初始化同义词表
    public static synchronized void initialize() {
        // 从资源文件加载同义词
        // 添加一些常用同义词
    }

    // 获取词的所有同义词
    public static Set<String> getSynonyms(String word) {
        // 获取词的所有同义词
    }

    // 判断两个词是否是同义词
    public static boolean areSynonyms(String word1, String word2) {
        // 判断两个词是否是同义词
    }
}
```

## 8. 后续改进方向

系统目前已经实现了基本功能，但仍有以下几个方面可以进一步改进：

1. **动态数据源**：

   - 将静态数据替换为数据库或配置文件，方便维护和更新
   - 支持通过管理界面动态添加、修改和删除组织、领导和职责领域数据

2. **词典和同义词完善**：

   - 扩充分词词典，增加更多领域相关词汇
   - 完善同义词表，提高匹配的灵活性
   - 引入词典和同义词的管理工具，方便维护

3. **关键词权重优化**：

   - 实现更精细的关键词权重计算方法
   - 根据关键词的重要性和专业性调整权重
   - 引入关键词评估工具，帮助管理员优化关键词

4. **用户界面**：

   - 开发 Web 界面或集成到现有系统，提供更友好的用户体验
   - 支持可视化展示推荐结果和匹配过程

5. **动态阈值策略完善**：

   - 实现更复杂的动态阈值计算策略
   - 根据不同业务场景自动调整阈值
   - 支持用户自定义阈值策略

6. **性能优化**：

   - 优化文本相似度算法的性能，减少计算开销
   - 引入缓存机制，提高系统响应速度

7. **多语言支持**：

   - 支持多语言环境，特别是中英文混合场景
   - 针对不同语言优化分词和相似度算法

8. **安全性增强**：

   - 增加用户认证和授权机制，控制访问权限
   - 加密敏感数据，保护用户隐私

9. **日志和监控**：
   - 完善日志记录，便于问题排查和系统优化
   - 增加监控功能，实时了解系统运行状态

通过以上改进，系统可以更好地满足实际业务需求，提供更准确、更高效的领导推荐服务。
